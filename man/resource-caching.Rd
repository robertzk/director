% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/resource-caching_layer.R
\name{resource caching}
\alias{resource caching}
\alias{caching_layer}
\title{Cache a resource's parsed value.}
\usage{
caching_layer(object, ..., recompile. = FALSE)
}
\arguments{
\item{object}{active_resource. See \code{\link{active_resource}}.}

\item{...}{additional parameters to pass to the next layer in the resource
parsing tower.}

\item{recompile.}{logical. Whether or not to force the resource to
be recompiled (instead of retrieved from cache), regardless of
whether the resource or any of its dependencies have been modified.}
}
\value{
The parsed resource, retrieved from cache since the last time
   the resource was executed if and only if the resource's file(s) and
   none of its (recursive) dependencies have been modified.
}
\description{
More complex resources are typically time-consuming to compile, or
are unnecessary to compile more than once per R session.
}
\details{
The \code{caching_layer} provides an internal caching mechanism that
will remember the value of the parsed resource and re-use it
\emph{unless the resource or any of its dependencies have been
modified} (see \link{dependency_tracking} for an explanation of
how this is accomplished).
}
\note{
The parameters must be named \code{object} and \code{...} due to
   this method's inclusion in a \code{\link{tower}}.
}
\examples{
\dontrun{
  # Imagine we are constructing a stagerunner from a sequence of functions.
  # However, some of those functions have been built by other resources.
  # Imagine the following structure.
  # (See github.com/robertzk/stagerunner for an explanation of stagerunners.)

  #=== /dir/runners/project1.R ===
  list(
    "import data"  = resource("importers/db"),   # These are some functions
    "munge data"   = resource("mungers/impute"), # built by the user
    "create model" = resource("models/lm"),      # that live in other
    "export model" = resource("exporters/file")  # files.
  )

  #=== R console ===
  d <- director("/dir") # Create a director object.
  d$register_parser("runners/", function(output) {
    stagerunner::stageRunner$new(new.env(), output)
  }, cache = TRUE) # Note the cache = TRUE argument.

  sr  <- d$resource("runners/project1") # A fresh new stageRunner!
  sr2 <- d$resource("runners/project1") # Same one, since it used the cache.
  stopifnot(identical(sr, sr2))

  # We can use base::Sys.setFileTime to pretend like we updated the
  # modified time of the /dir/connections/dev.R file, triggering
  # the caching layer to re-compile the resource.
  Sys.setFileTime(file.path(d$root(), "runners", "project1.R"),
    Sys.time() - as.difftime(1, units = "mins"))

  sr3 <- d$resource("runners/project1") # Now it re-builds the runner.
  stopifnot(!identical(sr, sr3)) # A new runner, with hardly any work!
}
}
\seealso{
\code{\link{active_resource}}, \code{\link{tower}}
}
