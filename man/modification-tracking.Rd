% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/resource-modification_tracker.R
\name{modification tracking}
\alias{modification tracking}
\alias{modification_tracker}
\title{Detect modifications to a resource.}
\usage{
modification_tracker(object, ..., modification_tracker.return = "object",
  modification_tracker.touch = TRUE)
}
\arguments{
\item{object}{active_resource. See \code{\link{active_resource}}.}

\item{...}{additional parameters to pass to the next layer in the resource
parsing tower.}

\item{modification_tracker.return}{character. What to return in this layer
   of the parsing tower. The options are \code{c("modified", "object")}.

   The former returns whether or not the file associated with the resource
   has been modified (or in the case of idempotent resources, the file and
   its helpers). The resource itself will not be parsed.

   The latter, \code{"object"}, will parse the resource as usual. This is
   the default.}

\item{modification_tracker.touch}{logical. Whether or not to update an
internal cache that keeps track of last time the resource is modified.
This is an internal parameter that is set to \code{FALSE} by recursive
calls to \code{director$resource} to avoid polluting the modification
cache while investigating dependency changes. The default is \code{TRUE}.}
}
\value{
The parsed resource.
}
\description{
The \code{modification_tracker} is responsible for determining whether
any changes have been made to the file(s) associated to the given
resource.
}
\details{
If a modification has been detected, the local \code{modified}
will be injected for use in the preprocessor or parser for the resource.

Note that we can use the \code{modification_tracker} to determine
whether the resource has been modified:

\code{director_object$resource(resource_name,
  modification_tracker.touch = FALSE,
  modification_tracker.return = "modified")}

The use of \code{modification_tracker.touch = FALSE} is necessary to avoid
polluting the internal cache that determines whether or not the resource
has been modified.
}
\note{
The parameters must be named \code{object} and \code{...} due to
   this method's inclusion in a \code{\link{tower}}.
}
\examples{
\dontrun{
  # Imagine we are constructing a stagerunner from a sequence of functions.
  # However, some of those functions have been built by other resources.
  # Imagine the following structure.
  # (See github.com/robertzk/stagerunner for an explanation of stagerunners.)

  #=== /dir/runners/project1.R ===
  list(
    "import data"  = resource("importers/db"),   # These are some functions
    "munge data"   = resource("mungers/impute"), # built by the user
    "create model" = resource("models/lm"),      # that live in other
    "export model" = resource("exporters/file")  # files.
  )

  #=== R console ===
  d <- director("/dir") # Create a director object.
  d$register_preprocessor("runners/", function(director, source, modified) {
    # `modified` has been set by the modification_tracker to
    # TRUE or FALSE according as /dir/runners/project1.R has been modified.
    if (modified || is.null(runner <- director$cache_get("last_runner"))) {
      # Construct a new stageRunner, since the file has been modified.
      source()
    } else { runner }
  })

  d$register_parser("runners/", function(output) {
    # If it is a stageRunner, it must have been retrieved from the cache.
    if (stagerunner::is.stageRunner(output)) { return(output) }
    runner <- stagerunner::stageRunner$new(new.env(), output)
 
    # Cache the runner so it is available in the preprocessor next time.
    # As long as the /dir/runners/project1.R file remains untouched, we will
    # not have to bother re-sourcing the file and hence reconstructing the
    # stageRunner.
    director$cache_set("last_runner", runner)
    runner
  })

  sr  <- d$resource("runners/project1") # A fresh new stageRunner!
  sr2 <- d$resource("runners/project1") # Same one, since it used the cache.
  stopifnot(identical(sr, sr2))

  # We can use base::Sys.setFileTime to pretend like we updated the
  # modified time of the project1.R file, triggering `modified = TRUE`.
  Sys.setFileTime(file.path(d$root(), "runners", "project1.R"),
    Sys.time() - as.difftime(1, units = "mins"))

  sr3 <- d$resource("runners/project1") # Now it re-builds the runner.
  stopifnot(!identical(sr, sr3)) # A new runner!
}
}
\seealso{
\code{\link{active_resource}}, \code{\link{tower}}
}
